#!/bin/bash
# vim: sw=2 sts=2 ts=8 et fdm=marker cms=\ #\ %s
#
# y2m - a tool to help with the checkout of the YaST git repos
#
# License: GPL2
# Homepage: http://github.com/yast/yast-meta.git

# Enable 'set -x' to get debug output (commands and arguments as they are executed):
#set -x

# Make sure to have a clean environment:
PATH="/sbin:/usr/sbin:/usr/bin:/bin"
LC_ALL="POSIX"
LANG="POSIX"
umask 022

# The return value of a pipeline is the status of
# the last command to exit with a non-zero status,
# or zero if no command exited with a non-zero status:
set -o pipefail

MY_NAME=${0##*/}

Y2MCONF=~/.y2m

# At https://github.com/yast see a repository
# e.g. https://github.com/yast/yast-yast2 which shows those URLs:
# For "SSH": git@github.com:yast/yast-yast2.git
# For "Git Read-Only": git://github.com/yast/yast-yast2.git
declare -Ar urls=(
  [c]=git@github.com
  [r]=git://github.com
)

declare -r cachedir=~/.y2mcache

do_clone() # {{{
{
  local remote=${1?} mod=${1##*/} moddir=${2?}
  echo "Cloning $remote..."
  git clone -q $remote $moddir
} # }}}

fetch_repos() # {{{
{
  # TODO cache more aggressively, query github only once in a while
  printf "Fetching repository names..."
  for org in libyui yast; do
    get_repos $org
    printf .
  done
  echo
} # }}}

get_repos() # {{{
{
  local org=${1?}
  local rv=0 pg=1

  mkdir -p $cachedir || {
    echo "$MY_NAME: mkdir -p $cachedir failed"
    exit 1
  } >&2

  while (( 0 == rv )); do
    get_repos_page $org $pg
    rv=$?
    pg=$((pg + 1))
  done
  if (( 2 < rv )); then
    echo "error listing repositories in github"
    exit 1
  fi >&2
  if (( 1 == rv )); then
    while test -f $cachedir/$org.$pg.curldump; do
      rm $cachedir/$org.$pg.*
      pg=$((pg + 1))
    done
    sort $cachedir/$org.*.repos > $cachedir/$org.repos
  fi
} # }}}

get_repos_page() # {{{
{
  local org=${1?}
  local pg=${2?}
  local pglen=100

  local headersfile=$cachedir/$org.$pg.headers
  local responsefile=$cachedir/$org.$pg.output
  local reposfile=$cachedir/$org.$pg.repos
  local curldump=$cachedir/$org.$pg.curldump

  local url="https://api.github.com/orgs/${org}/repos?page=${pg}&per_page=${pglen}"

  local etag=$(
    test -f $headersfile \
    && sed -n 's/^ETag: \("[^"]*"\).*/\1/p' $headersfile
  )

  curl --silent --verbose --show-error \
    --dump-header $headersfile \
    --output $responsefile \
    ${etag:+--header 'If-None-Match: '$etag} \
    --url $url 2> $curldump
  local rv=$?
  if (( 0 != rv )); then
    (( 2 >= rv )) && ((rv += 10))
    return $rv
  fi
  local status=$(head -1 $headersfile)
  case "$status" in
  (HTTP/*\ 200\ *) ;;
  (HTTP/*\ 304\ *) return 2 ;;
  (*) return 22 ;;
  esac
  sed -n -e '/"name":/s/^.*"name": "\([^"]*\)",.*$/\1/p' $responsefile \
  | sort \
  > $reposfile.tmp
  local rcnt=$(wc -l < $reposfile.tmp)
  mv $reposfile.tmp $reposfile
  (( rcnt == pglen )) || return 1
} # }}}

have_copy() # {{{
{
  local wanted=${1?} m=${2?}
  case "$wanted" in
  -y|--yes)
    test -d "$m" || {
      echo "Repo does not exist: $m"
      return 1
    }
  ;;
  -n|--no)
    test -d "$m" && {
      echo "Repo already cloned: $m"
      return 1
    }
  ;;
  *)
    echo "$MY_NAME: internal error; have_copy called with $@."
    exit 1
  ;;
  esac
  return 0
} >&2 # }}}

usage()
{
  echo
  echo "Y2M - the YaST2 meta tool"
  echo
  echo "This is a simple tool to help you to checkout all YaST modules, while"
  echo "maintaining the directory structure of the former svn repo."
  echo
  echo "With this tool you can"
  echo " * checkout all or just your favorite modules"
  echo " * switch all (or favorite) modules to a specific branch"
  echo " * run git pull on all (or favorite) modules"
  echo "with just one command."
  echo
  echo "Note: There is no need to use this tool."
  echo "      You can do everything manually as well."
  echo
  echo "Usage: $MY_NAME <command> [<modules>,..]"
  echo
  echo "commands"
  echo "    li|list      : list modules in 'yast' and 'libyui' repos"
  echo "    cl|clone     : run git clone for <modules>"
  echo "    ro|read-only : run git clone in read-only mode for <modules>"
  echo "    up|pull      : run git pull for a <modules>"
  echo "    co|br <name> : run git checkout to switch to branch <name> for <modules>"
  echo "modules"
  echo "    'ALL' : applies to all current known yast modules"
  echo "    'FAV' : applies to only your favorite modules, set in $Y2MCONF"
  echo "    <lowercase string> : applies to the named modules"
  echo
  echo "Reserved Branch and Tag Name Prefixes"
  echo
  echo "In order to maintain a certain consistency between the modules there are"
  echo "some prefixes that you should *not* use for your own branches/tags."
  echo "They are reserved for openSUSE or SLE releases."
  echo "Reserved prefixed for branches and tags:"
  echo " * 'openSUSE-'"
  echo " * 'SLE-'"
  echo " * 'Code-'"
  echo "See also: http://en.opensuse.org/YaST_SVN_to_GIT"
  echo
  exit ${1:-1}
}

createconfig()
{
  cat > $Y2MCONF <<EOYCONF
#
# .y2m config file
#
# This file holds some basic information for the y2m tool
#

#
# Your favorite modules (you either are the maintainer or just want to regularly track them)
# List of space separated module names including their new prefix:
#  e.g. "yast-core yast-network yast-installation libyui-qt"
Y2MFAVORITES=""
EOYCONF
}

[ -z "$1" -o "help" = "$1" ] && usage 0

[ -f $Y2MCONF ] || createconfig
# overwrite variables that are set in the config
[ -f $Y2MCONF ] && . $Y2MCONF

y2m-list() # {{{
{
  fetch_repos

  local org

  for org in yast libyui; do
    echo "Modules in '$org':"
    xargs < $cachedir/$org.repos | fold -sw 78
  done
} # }}}
y2m-clone() # {{{
{
  [[ $# -eq 0 ]] && {
    echo "usage: $MY_NAME $CMD (ALL|FAV|<module>...)"
    exit 1
  } >&2

  fetch_repos

  local -r url=${urls[${CMD:0:1}]}
  local org mod lmod

  if [[ $# -eq 1 && $1 == ALL ]]; then

    for org in libyui yast; do
      while read mod; do
        lmod=${mod#yast-}
        have_copy -n $lmod || continue
        do_clone "$url:$org/$mod" $lmod
      done < $cachedir/$org.repos
    done

  else

    [[ $# -eq 1 && $1 == FAV ]] && {
      set -- $Y2MFAVORITES
    }

    for lmod in $*; do
      org=$(basename $(grep -Flwe $lmod $cachedir/{libyui,yast}.repos) .repos)
      mod=$(grep -Ehwe "$lmod\$" $cachedir/{libyui,yast}.repos)
      lmod=${lmod#yast-}
      have_copy -n $lmod || continue
      do_clone "$url:$org/$mod" $lmod
    done

  fi
} # }}}
y2m-pull() # {{{
{
  local lmod

  [[ $# -eq 1 && $1 == FAV ]] && {
    set -- $Y2MFAVORITES
  }

  for lmod in ${*-*}; do
    lmod=${lmod#yast-}
    have_copy -y $lmod || continue
    (cd $lmod && git pull)
  done
} # }}}
y2m-checkout() # {{{
{
  local branch=$1
  local lmod
  shift

  [[ $# -eq 1 && $1 == FAV ]] && {
    set -- $Y2MFAVORITES
  }

  for lmod in ${*-*}; do
    lmod=${lmod#yast-}
    have_copy -y $lmod || continue
    GIT_WORK_TREE=$lmod GIT_DIR=$lmod/.git git checkout $branch
  done
} # }}}

CMD=$1
shift

case $CMD in
li|list)                  y2m-list        "$@" ;;
cl|clone|ro|read-only)    y2m-clone       "$@" ;;
up|pull)                  y2m-pull        "$@" ;;
br|co|checkout)           y2m-checkout    "$@" ;;
*)
  echo "Error: Unknown command: $CMD"
  echo "Run '$MY_NAME help' for more information."
  exit 1
;;
esac

